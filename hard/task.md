# Буферизованный читатель-писатель

Есть две сущности:
* Источник — Kafka;
* Потребитель — Clickhouse.

Источник отдает данные небольшими батчами, потребитель оптимальнее работает с крупными батчами.

## Что нужно сделать:
Необходимо передавать данные из источника в потребитель, эффективно группируя мелкие батчи в крупные для оптимизации обработки.
Методы `next`, `process` и `commit` связаны с сетевыми вызовами и могут работать довольно долго.
Для ускорения процесса передачи нужно сделать нужно распараллеливать процессы чтения, записи и подтверждения прогресса.
Так, чтобы при вызове `process` или `commit` продолжалось чтение из источника и формирование нового буфера.

## Типы и интерфейсы

### Producer (Источник данных)
```golang
type Producer interface {
// Next возвращает:
// - пакет элементов для обработки
// - cookie для подтверждения после обработки
// - ошибку 
Next() (items []any, cookie int, err error)

// Commit подтверждает обработку пакета данных
Commit(cookie int) error
}
```

Источник:
* При отсутствии новых данных возвращает `cookie` со значением `-1`.
* Источник никогда не возвращает более `maxItems` записей за один вызов `next`.
* В рамках одной "сессии" (одного вызова функции `pipe`) источник каждый раз возвращает новые данные на каждый вызов `next`.
* После перезапуска источник начнет с прошлой "подтвержденной" позиции, задаваемой `cookie`.
* Поэтому каждое значение `cookie`, которое вернул вызов `next`, после сохранения данных в приемнике,
  должно быть фиксировано вызовом `commit`, причем строго в той же последовательности, в которой их вернул `next`.

Представляет собой одну строку таблицы.
Элементы массива соответствуют колонкам таблицы.

### Consumer (Потребитель данных)
```golang
type Consumer interface {
// Process обрабатывает переданные элементы
Process(items []any) error
}
```

Приемник:
* Не может обработать более max_items за один раз.

## Требования:
Реализовать функцию `Pipe(p Producer, c Consumer, maxItems int) error`, которая:

* Читает данные из источника;
* Группирует их в буфер размером не более `MaxItems`;
* Сохраняет в потребитель;
* Фиксирует прогресс в источнике;

Для ускорения процесса передачи нужно сделать нужно распараллеливать процессы чтения, записи и подтверждения прогресса.

## Стартовый шаблон:
```golang
type Producer interface {
// Next возвращает:
// - пакет элементов для обработки
// - cookie для подтверждения после обработки
// - ошибку
Next() (items []any, cookie int, err error)

// Commit подтверждает обработку пакета данных
Commit(cookie int) error
}

type Consumer interface {
// Process обрабатывает переданные элементы
Process(items []any) error
}

func Pipe(p Producer, c Consumer, maxItems int) error {
// ... your code
}
```
